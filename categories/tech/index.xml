<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tech on Sourabh Deokar</title>
    <link>https://wilspi.com/categories/tech/</link>
    <description>Recent content in tech on Sourabh Deokar</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://wilspi.com/categories/tech/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Django Middleware: log requests and responses</title>
      <link>https://wilspi.com/post/tech/django-middleware-to-log-requests/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wilspi.com/post/tech/django-middleware-to-log-requests/</guid>
      <description>From Django&amp;rsquo;s context:
 Middleware is a framework of hooks into Django’s request/response processing.
It’s a light, low-level “plugin” system for globally altering Django’s input or output.
 Middleware is like a layer which processes every request and response. Instead of logging requests and responses in resp. views, its better to do at middleware layer which will log every incoming request. Why better?
 it will log unhandled requests/views one time job, no need to configure for every request/view  Here, we are using Django&amp;rsquo;s middleware semantics to construct a middleware which will log all requests and corresponding responses.</description>
    </item>
    
    <item>
      <title>Jinja template Inheritance using Database</title>
      <link>https://wilspi.com/post/tech/jinja-inheritance-using-db/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wilspi.com/post/tech/jinja-inheritance-using-db/</guid>
      <description>Jinja is a web template engine for the Python programming language. A Jinja template is simply a text file and can generate any text-based format (HTML, XML, CSV, LaTeX, etc.). A template contains variables and/or expressions, which get replaced with values when the template is rendered, thus serving dynamic content.
Commonly, templates are stored as files, either in git repo or s3 buckets. Depending on your use case, you can store the templates in database as well.</description>
    </item>
    
    <item>
      <title>Nix Recipe: Setup Postgresql</title>
      <link>https://wilspi.com/post/tech/nix-recipes/postgresql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wilspi.com/post/tech/nix-recipes/postgresql/</guid>
      <description>This is a nix recipe for building and running postgresql-12 in a virtual nix environment.
  Create your project folder and save the following file as shell.nix
let nixpkgs = import (builtins.fetchTarball https://github.com/NixOS/nixpkgs/archive/20.03.tar.gz) { overlays = []; config = {}; }; in with nixpkgs; stdenv.mkDerivation { name = &amp;quot;postgres-env&amp;quot;; buildInputs = []; nativeBuildInputs = [ zsh vim geos gdal nixpkgs-fmt # postgres-12 with postgis support (postgresql_12.withPackages (p: [ p.postgis ])) ]; postgresConf = writeText &amp;quot;postgresql.</description>
    </item>
    
    <item>
      <title>Nix shell and Awesomeness: An Intro</title>
      <link>https://wilspi.com/post/tech/nix-shell-and-awesomeness/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wilspi.com/post/tech/nix-shell-and-awesomeness/</guid>
      <description>Last year while working with @amitu, I came across this wonderful tool called Nix.
I have been using Nix for almost all my projects now. I have written nix recipes for:
rust, python, nodejs, elm, postgres, react, react-native.
About Nix, its wiki says:
 Nix is a package manager and build system that parses reproducible build instructions specified in the Nix Expression Language, a pure functional language with lazy evaluation</description>
    </item>
    
    <item>
      <title>Rust: Slog and multiple drains</title>
      <link>https://wilspi.com/post/tech/slogging-multiple-drains/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wilspi.com/post/tech/slogging-multiple-drains/</guid>
      <description>Slog is a structured logging library for Rustlang.
Structured logging is a concept that puts events over messages, events are logged with associated key-value data, not plain string messages. This helps in:
 processing log files for analytics searching and debugging  Logging Lets create a simple logger:
#[macro_use] extern crate slog; extern crate chrono; fn main() { let drain = slog::Discard; let root_logger = slog::Logger::root(drain, o!()); info!(root_logger, &amp;quot;Application started&amp;quot;; &amp;quot;started_at&amp;quot; =&amp;gt; format!</description>
    </item>
    
    <item>
      <title>Save the production with nginx</title>
      <link>https://wilspi.com/post/tech/save-production-via-nginx/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wilspi.com/post/tech/save-production-via-nginx/</guid>
      <description>Quick nginx hack to save your production web server in case the web service starts crashing.
If you have been working in production environment, you know at certain times your web service can crash due to some unknown reason (code failure). It will take some time to do the RCA and fix the issue. A quick hack is to have multiple web services running on different ports resp. that can take the load off, if any of them goes down.</description>
    </item>
    
    <item>
      <title>Setup multi user nix for Arch Linux</title>
      <link>https://wilspi.com/post/tech/setup-nix-arch-linux/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wilspi.com/post/tech/setup-nix-arch-linux/</guid>
      <description>Here we are setting up nix for Arch Linux.
Multi User Setup From nix&amp;rsquo;s page:
 To allow a Nix store to be shared safely among multiple users, it is important that users are not able to run builders that modify the Nix store or database in arbitrary ways, or that interfere with builds started by other users. If they could do so, they could install a Trojan horse in some package and compromise the accounts of other users.</description>
    </item>
    
  </channel>
</rss>