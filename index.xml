<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sourabh Deokar</title>
    <link>https://wilspi.com/</link>
    <description>Recent content on Sourabh Deokar</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://wilspi.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://wilspi.com/_about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wilspi.com/_about/</guid>
      <description>About wilspi.com is
 written in Hugo with Anatole theme hosted by Google domain and Github Pages  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://wilspi.com/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wilspi.com/readme/</guid>
      <description>wgi-content </description>
    </item>
    
    <item>
      <title>Django Middleware: log requests and responses</title>
      <link>https://wilspi.com/post/tech/django-middleware-to-log-requests/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wilspi.com/post/tech/django-middleware-to-log-requests/</guid>
      <description>From Django&amp;rsquo;s context:
 Middleware is a framework of hooks into Django’s request/response processing.
It’s a light, low-level “plugin” system for globally altering Django’s input or output.
 Middleware is like a layer which processes every request and response. Instead of logging requests and responses in resp. views, its better to do at middleware layer which will log every incoming request. Why better?
 it will log unhandled requests/views one time job, no need to configure for every request/view  Here, we are using Django&amp;rsquo;s middleware semantics to construct a middleware which will log all requests and corresponding responses.</description>
    </item>
    
    <item>
      <title>Nix shell and Awesomeness</title>
      <link>https://wilspi.com/post/tech/nix-shell-and-awesomeness/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wilspi.com/post/tech/nix-shell-and-awesomeness/</guid>
      <description>Last year while working with @amitu, I came across this wonderful tool called Nix.
About Nix, its wiki says:
 Nix is a package manager and build system that parses reproducible build instructions specified in the Nix Expression Language, a pure functional language with lazy evaluation
 Nix maintains the package versions including system libraries across OS environments and, hence never uses dependencies from the host system. All the version information is saved in your nix recipe (which you invoke through nix-shell command, we will see below).</description>
    </item>
    
    <item>
      <title>Save the production via nginx!</title>
      <link>https://wilspi.com/post/tech/save-production-via-nginx/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wilspi.com/post/tech/save-production-via-nginx/</guid>
      <description>Quick nginx hack to save your production web server in case the web service starts crashing.
If you have been working in production environment, you know at certain times your web service can crash due to some unknown reason. It will take some time to do the RCA and fix the issue. A quick hack is to have multiple web services running on different ports resp. that can take the load off, if any of them goes down.</description>
    </item>
    
  </channel>
</rss>