<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Rust: Slog and multiple drains | wilspi</title>

<meta name="keywords" content="rust, slog" />
<meta name="description" content="Slog is a structured logging library for Rustlang.
Structured logging is a concept that puts events over messages, events are logged with associated key-value data, not plain string messages. This helps in:
 processing log files for analytics searching and debugging (example: search log statements for particular user or request)  Logging Lets create a simple logger:
#[macro_use] extern crate slog; extern crate chrono; fn main() { let drain = slog::Discard; let root_logger = slog::Logger::root(drain, o!">
<meta name="author" content="wilspi">
<link rel="canonical" href="https://wilspi.com/post/tech/slogging-multiple-drains/" />
<link href="/assets/css/stylesheet.min.f580a29692e0c7eb72865ec0bd4ee916bef2dc7e85f4fbfdf6a609b3a0f4f6a1.css" integrity="sha256-9YCilpLgx&#43;tyhl7AvU7pFr7y3H6F9Pv99qYJs6D09qE=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="https://wilspi.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://wilspi.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://wilspi.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://wilspi.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://wilspi.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.79.0" />



<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-51915090-3', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<meta property="og:title" content="Rust: Slog and multiple drains" />
<meta property="og:description" content="Slog is a structured logging library for Rustlang.
Structured logging is a concept that puts events over messages, events are logged with associated key-value data, not plain string messages. This helps in:
 processing log files for analytics searching and debugging (example: search log statements for particular user or request)  Logging Lets create a simple logger:
#[macro_use] extern crate slog; extern crate chrono; fn main() { let drain = slog::Discard; let root_logger = slog::Logger::root(drain, o!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://wilspi.com/post/tech/slogging-multiple-drains/" />
<meta property="og:image" content="https://wilspi.com/images/cover.jpg"/>
<meta property="article:published_time" content="2020-08-03T22:00:00+05:30" />
<meta property="article:modified_time" content="2020-08-03T22:00:00+05:30" /><meta property="og:site_name" content="नमस्ते" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://wilspi.com/images/cover.jpg"/>

<meta name="twitter:title" content="Rust: Slog and multiple drains"/>
<meta name="twitter:description" content="Slog is a structured logging library for Rustlang.
Structured logging is a concept that puts events over messages, events are logged with associated key-value data, not plain string messages. This helps in:
 processing log files for analytics searching and debugging (example: search log statements for particular user or request)  Logging Lets create a simple logger:
#[macro_use] extern crate slog; extern crate chrono; fn main() { let drain = slog::Discard; let root_logger = slog::Logger::root(drain, o!"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://wilspi.com/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Rust: Slog and multiple drains",
      "item": "https://wilspi.com/post/tech/slogging-multiple-drains/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Rust: Slog and multiple drains",
  "name": "Rust: Slog and multiple drains",
  "description": "Slog is a structured logging library for Rustlang.\nStructured logging is a concept that puts events over messages, events are logged with associated key-value data, not plain …",
  "keywords": [
    "rust", "slog"
  ],
  "articleBody": "Slog is a structured logging library for Rustlang.\nStructured logging is a concept that puts events over messages, events are logged with associated key-value data, not plain string messages. This helps in:\n processing log files for analytics searching and debugging (example: search log statements for particular user or request)  Logging Lets create a simple logger:\n#[macro_use] extern crate slog; extern crate chrono; fn main() { let drain = slog::Discard; let root_logger = slog::Logger::root(drain, o!()); info!(root_logger, \"Application started\"; \"started_at\" = format!(\"{}\", chrono::Utc::now())); } Important terms:\n Drain is a trait which is responsible for deciding the output/destination of the logs. Any custom log handling logic should be implemented as a Drain. Context are key-value pairs that gets added into every log statement. Let’s say if you want to add the git commit version to each log statement you can add it here. Logger are objects used to execute logging statements.\nFor creating root logger, we need drain and context. Read complete documentation here.  Here, a root_logger object is created with drain Discard (which discards everything) and blank context (o!()).\n Lets look at another example:\n#[macro_use] extern crate slog; extern crate slog_term; extern crate chrono; use slog::Drain; fn main() { let decorator = slog_term::TermDecorator::new().build(); let drain = slog_term::FullFormat::new(decorator).build().fuse(); let root_logger = slog::Logger::root(drain, o!()); info!(root_logger, \"Application started\"; \"started_at\" = format!(\"{}\", chrono::Utc::now())); } Here, slog_term::FullFormat drain is used for terminal output with TermDecorator (Decorator is an implementing strategy of output formating in terms of IO, colors, etc.)\n Since drain is a trait to customize logging to any output, it allows slog to become extensible, composable, and flexible. There are many feature slog libraries based on this trait:\n slog-bunyan slog-term slog-async slog-journald etc.  You can always write your own implementation using this trait.\nMultiple Drains Drains can also be interlinked and extended according to our needs. Following is an example where there are two outputs:\n to stdout, all log statements are sent to stderr, log statements with log level greater than or equal to slog::Level::Warning are sent  #[macro_use] extern crate slog; extern crate slog_term; extern crate chrono; use slog::Drain; fn main() { let drain = slog_async::Async::new( slog::Duplicate::new( slog::Filter::new( slog_term::FullFormat::new( slog_term::PlainSyncDecorator::new(std::io::stderr(),)).build(), |record: \u0026slog::Record| record.level().is_at_least(slog::Level::Warning), ), slog_term::FullFormat::new(slog_term::PlainSyncDecorator::new(std::io::stdout())).build(), ).fuse() ).build().fuse(); let root_logger = slog::Logger::root(drain, o!()); info!(root_logger, \"Application started\"; \"started_at\" = format!(\"{}\", chrono::Utc::now())); } Here, Async, Duplicate, Filter, FullFormat drains are used.\nLog Macros and Log Levels To log a statement/record, we use log macros. In the above examples, info! is used.\nLog Levels are log categories based on urgency. For example, we have debug, info, error, etc. for self-explaining urgencies. We have different log macros for different log levels.\nExtra You can find many more examples, here.\n",
  "wordCount" : "438",
  "inLanguage": "en",
  "datePublished": "2020-08-03T22:00:00+05:30",
  "dateModified": "2020-08-03T22:00:00+05:30",
  "author":{
    "@type": "Person",
    "name": "wilspi"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://wilspi.com/post/tech/slogging-multiple-drains/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "wilspi",
    "logo": {
      "@type": "ImageObject",
      "url": "https://wilspi.com/favicon.ico"
    }
  }
}
</script>





</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://wilspi.com" accesskey="h" title="wilspi (Alt + H)">wilspi</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                
                
            </span>
        </div>
        <ul id="menu" onscroll="menu_on_scroll()">
            <li>
                <a href="https://wilspi.com/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://notes.wilspi.com" title="Notes">
                    <span>Notes</span>
                </a>
            </li></ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">

    <h1 class="post-title">
      Rust: Slog and multiple drains
    </h1>
    <div class="post-meta">

August 3, 2020&nbsp;·&nbsp;3 min&nbsp;·&nbsp;wilspi

</div>
  </header> 

  <div class="post-content">
<p><a href="https://github.com/slog-rs/slog">Slog</a> is a structured logging library for <a href="https://www.rust-lang.org/">Rustlang</a>.<br>
Structured logging is a concept that puts events over messages, events are logged with associated key-value data, not plain string messages.
This helps in:</p>
<ul>
<li>processing log files for analytics</li>
<li>searching and debugging (example: search log statements for particular user or request)</li>
</ul>
<h2 id="logging">Logging<a hidden class="anchor" aria-hidden="true" href="#logging">#</a></h2>
<p>Lets create a simple logger:</p>
<pre><code>#[macro_use]
extern crate slog;
extern crate chrono;

fn main() {
    let drain = slog::Discard;

    let root_logger = slog::Logger::root(drain, o!());

    info!(root_logger, &quot;Application started&quot;;
        &quot;started_at&quot; =&gt; format!(&quot;{}&quot;, chrono::Utc::now()));
}
</code></pre><p>Important terms:</p>
<ul>
<li>Drain is a <a href="https://doc.rust-lang.org/rust-by-example/trait.html">trait</a> which is responsible for deciding the output/destination of the logs. Any custom log handling logic should be implemented as a Drain.</li>
<li><a href="https://docs.rs/slog/2.5.2/slog/struct.OwnedKV.html">Context</a> are key-value pairs that gets added into every log statement. Let&rsquo;s say if you want to add the git commit version to each log statement you can add it here.</li>
<li>Logger are objects used to execute logging statements.<br>
For creating <a href="https://docs.rs/slog/2.5.2/slog/struct.Logger.html#method.root">root logger</a>, we need drain and context. Read complete documentation <a href="https://docs.rs/slog/2.5.2/slog/struct.Logger.html">here</a>.</li>
</ul>
<p>Here, a <code>root_logger</code> object is created with drain <a href="https://docs.rs/slog/2.0.0-3.1/slog/struct.Discard.html">Discard</a> (which discards everything) and blank context (<code>o!()</code>).</p>
<hr>
<p>Lets look at another example:</p>
<pre><code>#[macro_use]
extern crate slog;
extern crate slog_term;
extern crate chrono;

use slog::Drain;

fn main() {
    let decorator = slog_term::TermDecorator::new().build();
    let drain = slog_term::FullFormat::new(decorator).build().fuse();

    let root_logger = slog::Logger::root(drain, o!());

    info!(root_logger, &quot;Application started&quot;;
        &quot;started_at&quot; =&gt; format!(&quot;{}&quot;, chrono::Utc::now()));
}
</code></pre><p>Here, <a href="https://docs.rs/slog-term/2.0.2/slog_term/struct.FullFormat.html">slog_term::FullFormat</a> drain is used for terminal output with <a href="https://docs.rs/slog-term/2.0.2/slog_term/struct.TermDecorator.html">TermDecorator</a> (Decorator is an implementing strategy of output formating in terms of IO, colors, etc.)</p>
<hr>
<p>Since drain is a trait to customize logging to any output, it allows slog to become extensible, composable, and flexible.
There are many feature slog libraries based on this trait:</p>
<ul>
<li><a href="https://github.com/slog-rs/bunyan">slog-bunyan</a></li>
<li><a href="https://github.com/slog-rs/term">slog-term</a></li>
<li><a href="https://github.com/slog-rs/async">slog-async</a></li>
<li><a href="https://github.com/slog-rs/journald">slog-journald</a>
etc.</li>
</ul>
<p>You can always write your own implementation using this trait.</p>
<h2 id="multiple-drains">Multiple Drains<a hidden class="anchor" aria-hidden="true" href="#multiple-drains">#</a></h2>
<p>Drains can also be interlinked and extended according to our needs.
Following is an example where there are two outputs:</p>
<ul>
<li>to stdout, all log statements are sent</li>
<li>to stderr, log statements with log level greater than or equal to <code>slog::Level::Warning</code> are sent</li>
</ul>
<pre><code>#[macro_use]
extern crate slog;
extern crate slog_term;
extern crate chrono;

use slog::Drain;

fn main() {
    let drain = slog_async::Async::new(
        slog::Duplicate::new(
            slog::Filter::new(
                slog_term::FullFormat::new(
                    slog_term::PlainSyncDecorator::new(std::io::stderr(),)).build(),
                |record: &amp;slog::Record| record.level().is_at_least(slog::Level::Warning),
            ),
            slog_term::FullFormat::new(slog_term::PlainSyncDecorator::new(std::io::stdout())).build(),
        ).fuse()
    ).build().fuse();

    let root_logger = slog::Logger::root(drain, o!());

    info!(root_logger, &quot;Application started&quot;;
        &quot;started_at&quot; =&gt; format!(&quot;{}&quot;, chrono::Utc::now()));
}
</code></pre><p>Here, <a href="https://github.com/slog-rs/async">Async</a>, <a href="https://docs.rs/slog/2.5.2/slog/struct.Duplicate.html">Duplicate</a>, <a href="https://docs.rs/slog/2.5.2/slog/struct.Filter.html">Filter</a>, <a href="https://docs.rs/slog-term/2.0.2/slog_term/struct.FullFormat.html">FullFormat</a> drains are used.</p>
<h2 id="log-macros-and-log-levels">Log Macros and Log Levels<a hidden class="anchor" aria-hidden="true" href="#log-macros-and-log-levels">#</a></h2>
<p>To log a statement/record, we use <a href="https://docs.rs/slog/2.5.2/slog/macro.log.html">log macros</a>. In the above examples, <code>info!</code> is used.</p>
<p><a href="https://docs.rs/slog/2.0.0-3.1/slog/enum.Level.html">Log Levels</a> are log categories based on urgency. For example, we have debug, info, error, etc. for self-explaining urgencies.
We have different log macros for different log levels.</p>
<h2 id="extra">Extra<a hidden class="anchor" aria-hidden="true" href="#extra">#</a></h2>
<p>You can find many more examples, <a href="https://github.com/slog-rs/misc/tree/master/examples">here</a>.</p>

</div>
  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://wilspi.com/tags/rust/">rust</a></li>
      <li><a href="https://wilspi.com/tags/slog/">slog</a></li>
    </ul>
  </footer>
</article>
    </main><footer class="footer">
    <span>&middot;</span>
    <span>&copy; 2021 <a href="https://wilspi.com">wilspi</a></span>
    <span>&middot;</span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>



<script defer src="/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js" integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w="
    onload="hljs.initHighlightingOnLoad();"></script>
<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

</body>

</html>
